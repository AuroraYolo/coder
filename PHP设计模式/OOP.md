## 面向对象的特征
抽象:忽略一个主题中与当前目标无关的那些方面,以便更充分地注意与当前目标有关的方面.抽象并不打算了解全部问题,而只是选择其中一部分.
封装:将客观事物抽象成类,每个类对自身的数据和方法实现保护.
多态:允许不同类的对象对同一消息做出响应.
继承:继承是一种联结类的层次模型,并且允许和鼓励类的重用.

## 面向对象几大原则
单一职责:一个类最好只做一件事.为了提高内聚性减少引起变化,单一原则是低耦合,高内聚的面向原则上的引申.

开放封闭:软件的功能应该是可扩展的,尽可能减少修改.

里氏替换:只有子类能够替换基类,在继承机制的约束规范中,子类替换基类时,可以保证运行期内识别子类,保证类继承复用.

依赖倒置:高层模块不依赖底层模块,二者都依赖于抽象,抽象不依赖于实体,而实体依赖与抽象.依赖倒置原则可以有效的减少类之间的
       耦合性,提供系统的稳定性,减少并发引起的风险,提高代码的可读性和可维护性.
       
 接口隔离:建议开发使用多个小的,专门的接口,避免使用一个大的总接口.即每一个功能有一个专门的功能接口,需要用到才调用.
 可以提高代码的灵活性,降低类之间的耦合性,提高稳定性. 
 
 ## PHP魔术方法
 1）_construct()：构造函数，创建对象时自动被调用。
 2）_destruct()：析构函数，对象的所有引用都被删除或者当对象被显式销毁时执行。
 3）__clone()：克隆函数，调用clone方法时自动调用。
 4）__set()：当程序试图写入一个不存在或不可见的成员变量时自动调用。该函数在类中定义时必须有两个参数：变量名和变量值。
 5）__get()：当程序调用一个未定义或不可见的成员变量时自动调用__get()来读取变量值。定义时必有有一个参数：变量名。
 6）__call()：当程序试图调用不存在或不可见的成员方法时，自动调用__call()。__call()方法一般用于监视错误的方法调用。为了避免当调用的方法不存在时产生错误，可以使用__call()方法来避免。该方法包含两个参数：方法名和方法参数。其中，方法参数以数组形式存在。
 7）__sleep()：使用serialize()实现序列化对象时，先调用该方法，可以用来清除对象并返回一个该对象中所有变量的数组。
 8）__wakeup()：使用unserialize()还原一个被序列化的对象时，先执行该方法，恢复在序列化中可能丢失的数据库连接及相关工作。
 9）__toString()：当使用echo或print输出对象时，将对象转化为字符串。
 10）__autoload()：调用未被实例化的类时，自动调用，在指定路径下查找和该类名称相同的文件。   
 ##  $this、self和parent
 $this表示当前对象，在当前类中可以通过->符调用类内的属性和方法。
 self表示当前类，只能通过self的形式（“self::方法或属性”）调用类内的方法。
 parent表示当前类的父类，调用父类内的方法只能使用“parent::”形式调用。 
 ## 抽象类 接口
 被关键字abstract修饰的类叫作抽象类，抽象类是不能被实例化的。被abstract修饰的方法为抽象方法，一个类只要有一个抽象方法，这个类一定是抽象类。
 接口是通过关键字interface来定义的，可以指定某个类必须实现哪些方法，但不需要定义这些方法的具体实现。PHP类只支持是单重继承的，但通过接口可以实现PHP类的多重继承。
 抽象类和接口的不同和相似的地方如下所示。
 1）抽象类是一种不能被实例化的类，只能作为其他类的父类来使用。
 2）抽象类是通过关键字abstract来声明的。
 3）抽象类与普通类相似，都包含成员变量和成员方法，两者的区别在于，抽象类中至少要包含一个抽象方法。
 4）抽象方法没有方法体，该方法就是要被子类重写的。
 5）抽象方法的格式为：abstract function abstractMethod()。
 6）因为PHP中只支持单重继承，所以如果想实现多重继承，那么就要使用接口。也就是说，子类可以实现多个接口。
 7）接口类是通过interface关键字来声明的，接口类中的成员变量和方法都是public的，可以不用显式地使用public来修饰。
 8）接口中的方法没有方法体。接口中的方法就是要被子类继承实现的。
 9）子类继承抽象类使用extends关键字，子类实现接口使用implements关键字。 