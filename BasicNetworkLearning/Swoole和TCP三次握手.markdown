# TCP三次握手

#### 介绍
![avatar](TCP三次握手.jpg)

# 握手流程

第一次握手:建立连接时,客户端发送syn包(syn=j)到服务器,并进入SYN_SEND状态,等待服务器确认,SYN:同步序列编号    
第二次握手:服务器收到syn包,服务器将此请求信息放在半连接队列里(SYN queue 半连接队列 ),服务器必须确认客户的
syn(ack=j+1),同时自己也发送一个syn包(syn=k),即syn+ack包,此时服务器进入SYN_RECV状态;   
第三次握手:客户端收到服务器的SYN+ACK包,向服务器发送确认包ACK(ack=k+1),此包发送完毕,假设此时全连接队列未满,
那么从半连接队列中拿出此请求信息放入全连接队列里.假设全连接队列满了,那么客户端继续向服务端发送ACK包,
客户端和服务器进入ESTABLISHED状态,三次握手完成.服务器accept处理此请求,从全连接队列中将此请求信息拿出.
完成的握手也就是:请求->应答->再次确认.


# 握手常见问题
1.连接拒绝
2.Operation now in progress 
丢包、错误IP、backlog(见名词解释)满了&阻塞&tcp_abort_on_overflow=0

# 名词解释
backlog  客户端connect的时候,服务端accept连接,三次握手最后一次握手的时候,
服务器接收到客户端的ack包,将连接放入到一个叫accept queue里,backlog的定义是已连接但未进行accept处理的socket队列大小.
队列的大小由backlog决定.可以由ss -lt
命令查看最终的accept queue队列的长度大小.

# 为什么需要三次握手?
如果两次握手,那么server收到了客户端的SYN包后,便会分配资源并且向client发送一个ACK确认包.
在连接建立过程中,由于网络不顺畅等原因造成的通信链路中存在这残留数据包.客户端向服务器发送的请
求建立连接的数据包仍然在网络的链路中,残留的数据包会造成如下危害:当客户端与服务器建立连接,数据
发送完毕并且关闭TCP连接之后,如果链路中的残留数据包才到达服务器,那么服务器就会认为客户端重新发送
了一次请求建立,便会分配ACK包并且分配资源.并且一直等待客户端发送数据.造成服务器资源的浪费.

# 第三次握手失败了怎么办?
第三次握手失败,也就是客户端向服务器发送了ACK包,服务器未收到,或者等待超时了,那么服务器会向客户端发送
一个RTS(重置连接)报文段并进入关闭状态.即:并不等待客户端第三次握手的ACK包重传,直接关闭连接请求,这主要是为了防止
泛洪攻击,即有人伪造许多IP向服务器发送连接请求,从而将服务器的未连接队列塞满,浪费服务器的资源

# 防范攻击
1.缩短服务器接收客户端SYN报文之后的等待连接时间,即SYN timeout时间.过低的SYN timeout可能会影响正常的
TCP连接建立,一旦网络不通畅可能导致客户端连接失败.
2.SYN cookie + SYN proxy 
