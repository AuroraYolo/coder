## 索引常见的模型
数据结构:哈希表、有序数组、和搜索树.
哈希表适用于等值查询的场景.(应用场景:存储身份证信息和姓名的表)
有序数组适用于等值查询和范围查询.
二叉搜索树:每个节点左儿子小于父节点,右儿子大于父节点.
InnoDB引擎索引模型是:B+Tree

## 索引类型
主键索引 非主键索引

主键索引的叶子节点存的是整行的数据(聚簇索引),非主键索引的叶子节点存的的是主键的值(二级索引)

主键索引和普通索引的区别:主键索引只要搜索ID这个B+Tree即可拿到数据.普通索引先搜索索引拿到主键值,再到
主键索引数搜索一次(回表)

## 为何选择自增主键
从性能和存储空间方面考量,自增主键往往是更合理的选择.

主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小.

一个数据页满了,安装B+Tree算法,新增加一个数据页,叫做页分裂,会导致性能下架.空间利用率降低大概50%.当相邻
的两个数据页利用率很低的时候会做数据页合并,合并的过程是分裂过程的逆过程.

```
select * from T where k between 3 and 5;
表结构:
mysql> create table T (
ID int primary key,
k int NOT NULL DEFAULT 0, 
s varchar(16) NOT NULL DEFAULT '',
index k(k))
engine=InnoDB;

insert into T values(100,1, 'aa'),(200,2,'bb'),(300,3,'cc'),(500,5,'ee'),(600,6,'ff'),(700,7,'gg');
![avatar](https://static001.geekbang.org/resource/image/dc/8d/dcda101051f28502bd5c4402b292e38d.png)
SQL查询流程:
1.在k索引树上找到k=3的记录,取得ID=300;
2.再到ID索引数查到ID=300对应的R3;
3.在k索引树上取下一个值k=5,取得ID=500,
4.再回到ID索引数查到ID=500对应的R4;
5.在k索引数去下一个值k=6,不满足条件,循环结束.
```
## 回表
回到主键索引数搜索的过程,称之为回表.

## 覆盖索引
如果执行的语句是select ID from T where k between 3 and 5,这时只需要查ID的值,ID的值已经在k索引树上,可以直接提供查询结果,
不需要回表.索引k已经'覆盖了'查询需求,称之为覆盖索引

_**覆盖索引可以减少树的搜索次数,显著提升查询性能,所有使用覆盖索引时一个常用的优化手段.**_

## 最左前缀原则

B+数索引结构,可以利用索引的'最左前缀',来定位记录
比如(name,age)联合索引,只要满足最左前缀,就可以利用索引来加速检索.这个最左前缀可以是联合索引的最左N个字段,也可以是字符串索引的最左M个字符.

## 索引下推
MySQL5.6以后引入了索引下推优化,在索引遍历过程中,对索引中包含的字段先做判断,直接过滤掉不满足条件的记录,减少回表次数.
