## Reactor

```
第⼀种⽅案单 Reactor 单进程 / 线程，不⽤考虑进程间通信以及数据同步的问题，因此实现起来⽐较简
单，这种⽅案的缺陷在于⽆法充分利⽤多核 CPU，⽽且处理业务逻辑的时间不能太⻓，否则会延迟响应，
所以不适⽤于计算机密集型的场景，适⽤于业务处理快速的场景，⽐如 Redis 采⽤的是单 Reactor 单进程
的⽅案。
第⼆种⽅案单 Reactor 多线程，通过多线程的⽅式解决了⽅案⼀的缺陷，但它离⾼并发还差⼀点距离，差
在只有⼀个 Reactor 对象来承担所有事件的监听和响应，⽽且只在主线程中运⾏，在⾯对瞬间⾼并发的场
景时，容易成为性能的瓶颈的地⽅。
第三种⽅案多 Reactor 多进程 / 线程，通过多个 Reactor 来解决了⽅案⼆的缺陷，主 Reactor 只负责监听
事件，响应事件的⼯作交给了从 Reactor，Netty 和 Memcache 都采⽤了「多 Reactor 多线程」的⽅案，
Nginx 则采⽤了类似于 「多 Reactor 多进程」的⽅案。
Reactor 可以理解为「来了事件操作系统通知应⽤进程，让应⽤进程来处理」，⽽ Proactor 可以理解为
「来了事件操作系统来处理，处理完再通知应⽤进程」。
因此，真正的⼤杀器还是 Proactor，它是采⽤异步 I/O 实现的异步⽹络模型，感知的是已完成的读写事
件，⽽不需要像 Reactor 感知到事件后，还需要调⽤ read 来从内核中获取数据。
不过，⽆论是 Reactor，还是 Proactor，都是⼀种基于「事件分发」的⽹络编程模式，区别在于 Reactor
模式是基于「待完成」的 I/O 事件，⽽ Proactor 模式则是基于「已完成」的 I/O 事件。
```
