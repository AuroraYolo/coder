## 调度

````
进程都希望⾃⼰能够占⽤ CPU 进⾏⼯作，那么这涉及到前⾯说过的进程上下⽂切换。
⼀旦操作系统把进程切换到运⾏状态，也就意味着该进程占⽤着 CPU 在执⾏，但是当操作系统把进程切换
到其他状态时，那就不能在 CPU 中执⾏了，于是操作系统会选择下⼀个要运⾏的进程。
选择⼀个进程运⾏这⼀功能是在操作系统中完成的，通常称为调度程序（scheduler）。
````

## 调度时机

```
在进程的⽣命周期中，当进程从⼀个运⾏状态到另外⼀状态变化的时候，其实会触发⼀次调度。
⽐如，以下状态的变化都会触发操作系统的调度：
从就绪态 -> 运⾏态：当进程被创建时，会进⼊到就绪队列，操作系统会从就绪队列选择⼀个进程运
⾏；
从运⾏态 -> 阻塞态：当进程发⽣ I/O 事件⽽阻塞时，操作系统必须另外⼀个进程运⾏；
从运⾏态 -> 结束态：当进程退出结束后，操作系统得从就绪队列选择另外⼀个进程运⾏；
因为，这些状态变化的时候，操作系统需要考虑是否要让新的进程给 CPU 运⾏，或者是否让当前进程从
CPU 上退出来⽽换另⼀个进程运⾏。
另外，如果硬件时钟提供某个频率的周期性中断，那么可以根据如何处理时钟中断
，把调度算法分为两类：
⾮抢占式调度算法挑选⼀个进程，然后让该进程运⾏直到被阻塞，或者直到该进程退出，才会调⽤另
外⼀个进程，也就是说不会理时钟中断这个事情。
抢占式调度算法挑选⼀个进程，然后让该进程只运⾏某段时间，如果在该时段结束时，该进程仍然在
运⾏时，则会把它挂起，接着调度程序从就绪队列挑选另外⼀个进程。这种抢占式调度处理，需要在
时间间隔的末端发⽣时钟中断，以便把 CPU 控制返回给调度程序进⾏调度，也就是常说的时间⽚机
制。
```

## 调度原则

```
原则⼀：如果运⾏的程序，发⽣了 I/O 事件的请求，那 CPU 使⽤率必然会很低，因为此时进程在阻塞等待
硬盘的数据返回。这样的过程，势必会造成 CPU 突然的空闲。所以，为了提⾼ CPU 利⽤率，在这种发送
I/O 事件致使 CPU 空闲的情况下，调度程序需要从就绪队列中选择⼀个进程来运⾏。

原则⼆：有的程序执⾏某个任务花费的时间会⽐较⻓，如果这个程序⼀直占⽤着 CPU，会造成系统吞吐量
（CPU 在单位时间内完成的进程数量）的降低。所以，要提⾼系统的吞吐率，调度程序要权衡⻓任务和短
任务进程的运⾏完成数量。

原则三：从进程开始到结束的过程中，实际上是包含两个时间，分别是进程运⾏时间和进程等待时间，这
两个时间总和就称为周转时间。进程的周转时间越⼩越好，如果进程的等待时间很⻓⽽运⾏时间很短，那
周转时间就很⻓，这不是我们所期望的，调度程序应该避免这种情况发⽣。

原则四：处于就绪队列的进程，也不能等太久，当然希望这个等待的时间越短越好，这样可以使得进程更
快的在 CPU 中执⾏。所以，就绪队列中进程的等待时间也是调度程序所需要考虑的原则。
原则五：对于⿏标、键盘这种交互式⽐较强的应⽤，我们当然希望它的响应时间越快越好，否则就会影响
⽤户体验了。所以，对于交互式⽐较强的应⽤，响应时间也是调度程序需要考虑的原则。

针对上⾯的五种调度原则，总结成如下：
CPU 利⽤率：调度程序应确保 CPU 是始终匆忙的状态，这可提⾼ CPU 的利⽤率；
系统吞吐量：吞吐量表示的是单位时间内 CPU 完成进程的数量，⻓作业的进程会占⽤较⻓的 CPU 资
源，因此会降低吞吐量，相反，短作业的进程会提升系统吞吐量；
周转时间：周转时间是进程运⾏和阻塞时间总和，⼀个进程的周转时间越⼩越好；
等待时间：这个等待时间不是阻塞状态的时间，⽽是进程处于就绪队列的时间，等待的时间越⻓，⽤
户越不满意；
响应时间：⽤户提交请求到系统第⼀次产⽣响应所花费的时间，在交互式系统中，响应时间是衡量调
度算法好坏的主要标准。
```
