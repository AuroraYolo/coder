## 虚拟内存地址
程序所使用的内存地址叫做虚拟内存地址

## 物理内存地址
实际存在硬件里面的空间地址叫物理内存地址

#### 操作系统引⼊了虚拟内存，进程持有的虚拟地址会通过 CPU 芯⽚中的内存管理单元（MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存

## 内存分段

程序是由若⼲个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。不同的段是有不同的属
性的，所以就⽤分段（Segmentation）的形式把这些段分离出来。


对于多进程的系统来说，⽤分段的⽅式，内存碎⽚是很容易产⽣的，产⽣了内存碎⽚，那不得不重新
Swap 内存区域，这个过程会产⽣性能瓶颈。
因为硬盘的访问速度要⽐内存慢太多了，每⼀次内存交换，我们都需要把⼀⼤段连续的内存数据写到硬盘
上。
所以，如果内存交换的时候，交换的是⼀个占内存空间很⼤的程序，这样整个机器都会显得卡顿。
为了解决内存分段的内存碎⽚和内存交换效率低的问题，就出现了内存分⻚。
## 内存分页

分段的好处就是能产⽣连续的内存空间，但是会出现内存碎⽚和内存交换的空间太⼤的问题。
要解决这些问题，那么就要想出能少出现⼀些内存碎⽚的办法。另外，当需要进⾏内存交换的时候，让需
要交换写⼊或者从磁盘装载的数据更少⼀点，这样就可以解决问题了。这个办法，也就是内存分⻚
（Paging）。
分⻚是把整个虚拟和物理内存空间切成⼀段段固定尺⼨的⼤⼩。这样⼀个连续并且尺⼨固定的内存空间，
我们叫⻚（Page）。在 Linux 下，每⼀⻚的⼤⼩为 4KB 。


## 总结
为了在多进程环境下，使得进程之间的内存地址不受影响，相互隔离，于是操作系统就为每个进程独⽴分
配⼀套虚拟地址空间，每个程序只关⼼⾃⼰的虚拟地址就可以，实际上⼤家的虚拟地址都是⼀样的，但分
布到物理地址内存是不⼀样的。作为程序，也不⽤关⼼物理地址的事情。
每个进程都有⾃⼰的虚拟空间，⽽物理内存只有⼀个，所以当启⽤了⼤量的进程，物理内存必然会很紧
张，于是操作系统会通过内存交换技术，把不常使⽤的内存暂时存放到硬盘（换出），在需要的时候再装
载回物理内存（换⼊）。
那既然有了虚拟地址空间，那必然要把虚拟地址「映射」到物理地址，这个事情通常由操作系统来维护。
那么对于虚拟地址与物理地址的映射关系，可以有分段和分⻚的⽅式，同时两者结合都是可以的。
内存分段是根据程序的逻辑⻆度，分成了栈段、堆段、数据段、代码段等，这样可以分离出不同属性的
段，同时是⼀块连续的空间。但是每个段的⼤⼩都不是统⼀的，这就会导致内存碎⽚和内存交换效率低的
问题。
于是，就出现了内存分⻚，把虚拟空间和物理空间分成⼤⼩固定的⻚，如在 Linux 系统中，每⼀⻚的⼤⼩
为 4KB 。由于分了⻚后，就不会产⽣细⼩的内存碎⽚。同时在内存交换的时候，写⼊硬盘也就⼀个⻚或
⼏个⻚，这就⼤⼤提⾼了内存交换的效率。
再来，为了解决简单分⻚产⽣的⻚表过⼤的问题，就有了多级⻚表，它解决了空间上的问题，但这就会导
致 CPU 在寻址的过程中，需要有很多层表参与，加⼤了时间上的开销。于是根据程序的局部性原理，在
CPU 芯⽚中加⼊了 TLB，负责缓存最近常被访问的⻚表项，⼤⼤提⾼了地址的转换速度。
Linux 系统主要采⽤了分⻚管理，但是由于 Intel 处理器的发展史，Linux 系统⽆法避免分段管理。于是
Linux 就把所有段的基地址设为 0 ，也就意味着所有程序的地址空间都是线性地址空间（虚拟地址），相
当于屏蔽了 CPU 逻辑地址的概念，所以段只被⽤于访问控制和内存保护。
另外，Linxu 系统中虚拟空间分布可分为⽤户态和内核态两部分，其中⽤户态的分布：代码段、全局变量、
BSS、函数栈、堆内存、映射区。
