### CPU缓存一致性

```
CPU 在读写数据的时候，都是在 CPU Cache 读写数据的，原因是 Cache 离 CPU 很近，读写性能相⽐内
存⾼出很多。对于 Cache ⾥没有缓存 CPU 所需要读取的数据的这种情况，CPU 则会从内存读取数据，并
将数据缓存到 Cache ⾥⾯，最后 CPU 再从 Cache 读取数据。
⽽对于数据的写⼊，CPU 都会先写⼊到 Cache ⾥⾯，然后再在找个合适的时机写⼊到内存，那就有「写
直达」和「写回」这两种策略来保证 Cache 与内存的数据⼀致性：
写直达，只要有数据写⼊，都会直接把数据写⼊到内存⾥⾯，这种⽅式简单直观，但是性能就会受限
于内存的访问速度；
写回，对于已经缓存在 Cache 的数据的写⼊，只需要更新其数据就可以，不⽤写⼊到内存，只有在
需要把缓存⾥⾯的脏数据交换出去的时候，才把数据同步到内存⾥，这种⽅式在缓存命中率⾼的情
况，性能会更好；
当今 CPU 都是多核的，每个核⼼都有各⾃独⽴的 L1/L2 Cache，只有 L3 Cache 是多个核⼼之间共享的。
所以，我们要确保多核缓存是⼀致性的，否则会出现错误的结果。
要想实现缓存⼀致性，关键是要满⾜ 2 点：
第⼀点是写传播，也就是当某个 CPU 核⼼发⽣写⼊操作时，需要把该事件⼴播通知给其他核⼼；
第⼆点是事物的串⾏化，这个很重要，只有保证了这个，才能保障我们的数据是真正⼀致的，我们的
程序在各个不同的核⼼上运⾏的结果也是⼀致的；
基于总线嗅探机制的 MESI 协议，就满⾜上⾯了这两点，因此它是保障缓存⼀致性的协议。
MESI 协议，是已修改、独占、共享、已实现这四个状态的英⽂缩写的组合。整个 MSI 状态的变更，则是
根据来⾃本地 CPU 核⼼的请求，或者来⾃其他 CPU 核⼼通过总线传输过来的请求，从⽽构成⼀个流动的
状态机。另外，对于在「已修改」或者「独占」状态的 Cache Line，修改更新其数据不需要发送⼴播给其
他 CPU 核⼼。
```
