## 进程
我们编写的代码只是⼀个存储在硬盘的静态⽂件，通过编译后就会⽣成⼆进制可执⾏⽂件，当我们运⾏这
个可执⾏⽂件后，它会被装载到内存中，接着 CPU 会执⾏程序中的每⼀条指令，那么这个运⾏中的程序，
就被称为「进程」（Process）。

当进程要从硬盘读取数据时，CPU 不需要阻塞等待数据的返回，⽽是去执⾏另外的进程。当硬盘数
据返回时，CPU 会收到个中断，于是 CPU 再继续运⾏这个进程。

对于⼀个⽀持多进程的系统，CPU 会从⼀个进程快速切换⾄另⼀个进程，其间每个进程各运⾏⼏⼗或⼏百
个毫秒。
虽然单核的 CPU 在某⼀个瞬间，只能运⾏⼀个进程。但在 1 秒钟期间，它可能会运⾏多个进程，这样就
产⽣并⾏的错觉，实际上这是并发。

CPU 可以从⼀个进程（做菜）切换到另外⼀个进程（买可乐），在切换前必须要记录当前进程
中运⾏的状态信息，以备下次切换回来的时候可以恢复执⾏。

## 进程状态

在⼀个进程的活动期间⾄少具备三种基本状态，即运⾏状态、就绪状态、阻塞状态。

```
运⾏状态（Runing）：该时刻进程占⽤ CPU；
就绪状态（Ready）：可运⾏，由于其他进程处于运⾏状态⽽暂时停⽌运⾏；
阻塞状态（Blocked）：该进程正在等待某⼀事件发⽣（如等待输⼊/输出操作的完成）⽽暂时停⽌运
⾏，这时，即使给它CPU控制权，它也⽆法运⾏；
创建状态（new）：进程正在被创建时的状态；
结束状态（Exit）：进程正在从系统中消失时的状态；
```
## 进程的状态变迁

```
NULL -> 创建状态：⼀个新进程被创建时的第⼀个状态；
创建状态 -> 就绪状态：当进程被创建完成并初始化后，⼀切就绪准备运⾏时，变为就绪状态，这个
过程是很快的；
就绪态 -> 运⾏状态：处于就绪状态的进程被操作系统的进程调度器选中后，就分配给 CPU 正式运⾏
该进程；
运⾏状态 -> 结束状态：当进程已经运⾏完成或出错时，会被操作系统作结束状态处理；
运⾏状态 -> 就绪状态：处于运⾏状态的进程在运⾏过程中，由于分配给它的运⾏时间⽚⽤完，操作
系统会把该进程变为就绪态，接着从就绪态选中另外⼀个进程运⾏；
运⾏状态 -> 阻塞状态：当进程请求某个事件且必须等待时，例如请求 I/O 事件；
阻塞状态 -> 就绪状态：当进程要等待的事件完成时，它从阻塞状态变到就绪状态；
```
## 进程的控制结构

```
进程描述信息
进程标志符:标识各个进程,每个进程都有一个并且唯一的标识符;
用户标识符:进程归属的用户，用户标识符主要为共享和保护服务

进程控制和管理信息
进程当前状态：new,redy,running,waiting,blocked
进程优先级:进程抢占CPU时的优先级

资源分配清单
有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的I/O设备信息

CPU相关信息
CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程
重新执⾏时，能从断点处继续执⾏。

每个 PCB 是如何组织的呢？

通常是通过链表的⽅式进⾏组织，把具有相同状态的进程链在⼀起，组成各种队列。⽐如：
将所有处于就绪状态的进程链在⼀起，称为就绪队列；
把所有因等待某事件⽽处于等待状态的进程链在⼀起就组成各种阻塞队列；
另外，对于运⾏队列在单核 CPU 系统中则只有⼀个运⾏指针了，因为单核 CPU 在某个时间，只能运
⾏⼀个程序。

除了链接的组织⽅式，还有索引⽅式，它的⼯作原理：将同⼀状态的进程组织在⼀个索引表中，索引表项
指向相应的 PCB，不同状态对应不同的索引表。
⼀般会选择链表，因为可能⾯临进程创建，销毁等调度导致进程状态发⽣变化，所以链表能够更加灵活的
插⼊和删除。

```

## 进程的控制

```
01 创建进程
操作系统允许⼀个进程创建另⼀个进程，⽽且允许⼦进程继承⽗进程所拥有的资源，当⼦进程被终⽌时，
其在⽗进程处继承的资源应当还给⽗进程。同时，终⽌⽗进程时同时也会终⽌其所有的⼦进程。

创建进程的过程如下
1.为进程分配一个唯一的进程标识号，并申请一个空白的PCB，PCB是有限的，若申请失败则创建失败
2.为进程分配资源，此处如果资源不足，进程就会进入等待状态，以等待资源
3.初始化PCB
4.如果进程的调度队列能过接纳新进程,那就将进程插入到就绪队列，等待被调度运行

02 终止进程

进程可以有 3 种终⽌⽅式：正常结束、异常结束以及外界⼲预（信号 kill 掉）。
终⽌进程的过程如下：
查找需要终⽌的进程的 PCB；
如果处于执⾏状态，则⽴即终⽌该进程的执⾏，然后将 CPU 资源分配给其他进程；
如果其还有⼦进程，则应将其所有⼦进程终⽌；
将该进程所拥有的全部资源都归还给⽗进程或操作系统；
将其从 PCB 所在队列中删除；

03 阻塞进程
当进程需要等待某一事件完成时,它可以调用阻塞语句把自己阻塞等待。而一旦被阻塞等待，它只能由另一个进程唤醒。

阻塞进程的过程如下：
找到将要被阻塞进程标识号对应的 PCB；
如果该进程为运⾏状态，则保护其现场，将其状态转为阻塞状态，停⽌运⾏；
将该 PCB 插⼊到阻塞队列中去；

04 唤醒进程

进程由「运⾏」转变为「阻塞」状态是由于进程必须等待某⼀事件的完成，所以处于阻塞状态的进程是绝
对不可能叫醒⾃⼰的。
如果某进程正在等待 I/O 事件，需由别的进程发消息给它，则只有当该进程所期待的事件出现时，才由发
现者进程⽤唤醒语句叫醒它。
唤醒进程的过程如下：
在该事件的阻塞队列中找到相应进程的 PCB；
将其从阻塞队列中移出，并置其状态为就绪状态；
把该 PCB 插⼊到就绪队列中，等待调度程序调度；
进程的阻塞和唤醒是⼀对功能相反的语句，如果某个进程调⽤了阻塞语句，则必有⼀个与之对应的唤醒语
句。

```

## 进程的上下文切换

```
各个进程之间是共享 CPU 资源的，在不同的时候进程之间需要切换，让不同的进程可以在 CPU 执⾏，那
么这个⼀个进程切换到另⼀个进程运⾏，称为进程的上下⽂切换。

进程的上下⽂切换到底是切换什么呢？

进程是由内核管理和调度的，所以进程的切换只能发⽣在内核态。
所以，进程的上下⽂切换不仅包含了虚拟内存、栈、全局变量等⽤户空间的资源，还包括了内核堆栈、寄
存器等内核空间的资源。
通常，会把交换的信息保存在进程的 PCB，当要运⾏另外⼀个进程的时候，我们需要从这个进程的 PCB
取出上下⽂，然后恢复到 CPU 中，这使得这个进程可以继续执⾏

发⽣进程上下⽂切换有哪些场景？
为了保证所有进程可以得到公平调度，CPU 时间被划分为⼀段段的时间⽚，这些时间⽚再被轮流分配
给各个进程。这样，当某个进程的时间⽚耗尽了，进程就从运⾏状态变为就绪状态，系统从就绪队列
选择另外⼀个进程运⾏；
进程在系统资源不⾜（⽐如内存不⾜）时，要等到资源满⾜后才可以运⾏，这个时候进程也会被挂
起，并由系统调度其他进程运⾏；
当进程通过睡眠函数 sleep 这样的⽅法将⾃⼰主动挂起时，⾃然也会重新调度；
当有优先级更⾼的进程运⾏时，为了保证⾼优先级进程的运⾏，当前进程会被挂起，由⾼优先级进程
来运⾏；
发⽣硬件中断时，CPU 上的进程会被中断挂起，转⽽执⾏内核中的中断服务程序；

```
