## 管道
```bash
 ps auxf | grep mysql
```
```
上⾯命令⾏⾥的「 | 」竖线就是⼀个管道，它的功能是将前⼀个命令（ ps auxf ）的输出，作为后⼀个命
令（ grep mysql ）的输⼊，从这功能描述，可以看出管道传输数据是单向的，如果想相互通信，我们需
要创建两个管道才⾏。
同时，我们得知上⾯这种管道是没有名字，所以「 | 」表示的管道称为匿名管道，⽤完了就销毁。
管道还有另外⼀个类型是命名管道，也被叫做 FIFO ，因为数据是先进先出的传输⽅式。

管道这种通信⽅式效率低，不适合进程间频繁地交换数据

其实，所谓的管道，就是内核⾥⾯的⼀串缓存。从管道的⼀段写⼊的数据，实际上是缓存在内核中的，另
⼀端读取，也就是从内核中读取这段数据。另外，管道传输的数据是⽆格式的流且⼤⼩受限。
看到这，你可能会有疑问了，这两个描述符都是在⼀个进程⾥⾯，并没有起到进程间通信的作⽤，怎么样
才能使得管道是跨过两个进程的呢？
我们可以使⽤ fork 创建⼦进程，创建的⼦进程会复制⽗进程的⽂件描述符，这样就做到了两个进程各有
两个「 fd[0] 与 fd[1] 」，两个进程就可以通过各⾃的 fd 写⼊和读取同⼀个管道⽂件实现跨进程通信
了。
```

## 消息队列
```
前⾯说到管道的通信⽅式是效率低的，因此管道不适合进程间频繁地交换数据。
对于这个问题，消息队列的通信模式就可以解决。⽐如，A 进程要给 B 进程发送消息，A 进程把数据放在
对应的消息队列后就可以正常返回了，B 进程需要的时候再去读取数据就可以了。同理，B 进程要给 A 进
程发送消息也是如此。
再来，消息队列是保存在内核中的消息链表，在发送数据时，会分成⼀个⼀个独⽴的数据单元，也就是消
息体（数据块），消息体是⽤户⾃定义的数据类型，消息的发送⽅和接收⽅要约定好消息体的数据类型，
所以每个消息体都是固定⼤⼩的存储块，不像管道是⽆格式的字节流数据。如果进程从消息队列中读取了
消息体，内核就会把这个消息体删除。
消息队列⽣命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会⼀直存在，⽽前⾯
提到的匿名管道的⽣命周期，是随进程的创建⽽建⽴，随进程的结束⽽销毁。
消息这种模型，两个进程之间的通信就像平时发邮件⼀样，你来⼀封，我回⼀封，可以频繁沟通了。
但邮件的通信⽅式存在不⾜的地⽅有两点，⼀是通信不及时，⼆是附件也有⼤⼩限制，这同样也是消息队
列通信不⾜的点。
消息队列不适合⽐较⼤数据的传输，因为在内核中每个消息体都有⼀个最⼤⻓度的限制，同时所有队列所
包含的全部消息体的总⻓度也是有上限。在 Linux 内核中，会有两个宏定义 MSGMAX 和 MSGMNB ，
它们以字节为单位，分别定义了⼀条消息的最⼤⻓度和⼀个队列的最⼤⻓度。
消息队列通信过程中，存在⽤户态与内核态之间的数据拷⻉开销，因为进程写⼊数据到内核中的消息队列
时，会发⽣从⽤户态拷⻉数据到内核态的过程，同理另⼀进程读取内核中的消息数据时，会发⽣从内核态
拷⻉数据到⽤户态的过程。
```

## 共享内存
```
消息队列的读取和写⼊的过程，都会有发⽣⽤户态与内核态之间的消息拷⻉过程。那共享内存的⽅式，就
很好的解决了这⼀问题。
现代操作系统，对于内存管理，采⽤的是虚拟内存技术，也就是每个进程都有⾃⼰独⽴的虚拟内存空间，
不同进程的虚拟内存映射到不同的物理内存中。所以，即使进程 A 和 进程 B 的虚拟地址是⼀样的，其实
访问的是不同的物理内存地址，对于数据的增删查改互不影响。
共享内存的机制，就是拿出⼀块虚拟地址空间来，映射到相同的物理内存中。这样这个进程写⼊的东⻄，
另外⼀个进程⻢上就能看到了，都不需要拷⻉来拷⻉去，传来传去，⼤⼤提⾼了进程间通信的速度。
```

## 信号量
```
⽤了共享内存通信⽅式，带来新的问题，那就是如果多个进程同时修改同⼀个共享内存，很有可能就冲突
了。例如两个进程都同时写⼀个地址，那先写的那个进程会发现内容被别⼈覆盖了。
为了防⽌多进程竞争共享资源，⽽造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只
能被⼀个进程访问。正好，信号量就实现了这⼀保护机制。
信号量其实是⼀个整型的计数器，主要⽤于实现进程间的互斥与同步，⽽不是⽤于缓存进程间通信的数
据。
信号量表示资源的数量，控制信号量的⽅式有两种原⼦操作：
⼀个是 P 操作，这个操作会把信号量减去 1，相减后如果信号量 < 0，则表明资源已被占⽤，进程需
阻塞等待；相减后如果信号量 >= 0，则表明还有资源可使⽤，进程可正常继续执⾏。
另⼀个是 V 操作，这个操作会把信号量加上 1，相加后如果信号量 <= 0，则表明当前有阻塞中的进
程，于是会将该进程唤醒运⾏；相加后如果信号量 > 0，则表明当前没有阻塞中的进程；
P 操作是⽤在进⼊共享资源之前，V 操作是⽤在离开共享资源之后，这两个操作是必须成对出现的。
```
## 信号
```
上⾯说的进程间通信，都是常规状态下的⼯作模式。对于异常情况下的⼯作模式，就需要⽤「信号」的⽅
式来通知进程。
信号跟信号量虽然名字相似度 66.66%，但两者⽤途完全不⼀样，就好像 Java 和 JavaScript 的区别。
在 Linux 操作系统中， 为了响应各种各样的事件，提供了⼏⼗种信号，分别代表不同的意义。我们可以通
过 kill -l 命令，查看所有的信号：
$ kill -l
 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP
 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10) SIGUSR1
11) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM
16) SIGSTKFLT 17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP
21) SIGTTIN 22) SIGTTOU 23) SIGURG 24) SIGXCPU 25) SIGXFSZ
26) SIGVTALRM 27) SIGPROF 28) SIGWINCH 29) SIGIO 30) SIGPWR
31) SIGSYS 34) SIGRTMIN 35) SIGRTMIN+1 36) SIGRTMIN+2 37) SIGRTMIN+3
38) SIGRTMIN+4 39) SIGRTMIN+5 40) SIGRTMIN+6 41) SIGRTMIN+7 42) SIGRTMIN+8
43) SIGRTMIN+9 44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12
53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9 56) SIGRTMAX-8 57) SIGRTMAX-7
58) SIGRTMAX-6 59) SIGRTMAX-5 60) SIGRTMAX-4 61) SIGRTMAX-3 62) SIGRTMAX-2
63) SIGRTMAX-1 64) SIGRTMAX
运⾏在 shell 终端的进程，我们可以通过键盘输⼊某些组合键的时候，给进程发送信号。例如
Ctrl+C 产⽣ SIGINT 信号，表示终⽌该进程；
Ctrl+Z 产⽣ SIGTSTP 信号，表示停⽌该进程，但还未结束；
如果进程在后台运⾏，可以通过 kill 命令的⽅式给进程发送信号，但前提需要知道运⾏中的进程 PID
号，例如：
kill -9 1050 ，表示给 PID 为 1050 的进程发送 SIGKILL 信号，⽤来⽴即结束该进程；
所以，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令）。
信号是进程间通信机制中唯⼀的异步通信机制，因为可以在任何时候发送信号给某⼀进程，⼀旦有信号产
⽣，我们就有下⾯这⼏种，⽤户进程对信号的处理⽅式。
1.执⾏默认操作。Linux 对每种信号都规定了默认操作，例如，上⾯列表中的 SIGTERM 信号，就是终⽌进
程的意思。
2.捕捉信号。我们可以为信号定义⼀个信号处理函数。当信号发⽣时，我们就执⾏相应的信号处理函数。
3.忽略信号。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应⽤
进程⽆法捕捉和忽略的，即 SIGKILL 和 SEGSTOP ，它们⽤于在任何时候中断或结束某⼀进程。
```

## Socket
```
前⾯提到的管道、消息队列、共享内存、信号量和信号都是在同⼀台主机上进⾏进程间通信，那要想跨⽹
络与不同主机上的进程之间通信，就需要 Socket 通信了。
实际上，Socket 通信不仅可以跨⽹络与不同主机的进程间通信，还可以在同主机上进程间通信。
我们来看看创建 socket 的系统调⽤：
int socket(int domain, int type, int protocal)
三个参数分别代表：
domain 参数⽤来指定协议族，⽐如 AF_INET ⽤于 IPV4、AF_INET6 ⽤于 IPV6、
AF_LOCAL/AF_UNIX ⽤于本机；
type 参数⽤来指定通信特性，⽐如 SOCK_STREAM 表示的是字节流，对应 TCP、SOCK_DGRAM
表示的是数据报，对应 UDP、SOCK_RAW 表示的是原始套接字；
protocal 参数原本是⽤来指定通信协议的，但现在基本废弃。因为协议已经通过前⾯两个参数指定完
成，protocol ⽬前⼀般写成 0 即可；
根据创建 socket 类型的不同，通信的⽅式也就不同：
实现 TCP 字节流通信： socket 类型是 AF_INET 和 SOCK_STREAM；
实现 UDP 数据报通信：socket 类型是 AF_INET 和 SOCK_DGRAM；
实现本地进程间通信： 「本地字节流 socket 」类型是 AF_LOCAL 和 SOCK_STREAM，「本地数据
报 socket 」类型是 AF_LOCAL 和 SOCK_DGRAM。另外，AF_UNIX 和 AF_LOCAL 是等价的，所以
AF_UNIX 也属于本地 socket；
接下来，简单说⼀下这三种通信的编程模式。
针对 TCP 协议通信的 socket 编程模型
服务端和客户端初始化 socket ，得到⽂件描述符；
服务端调⽤ bind ，将绑定在 IP 地址和端⼝;
服务端调⽤ listen ，进⾏监听；
服务端调⽤ accept ，等待客户端连接；
客户端调⽤ connect ，向服务器端的地址和端⼝发起连接请求；
服务端 accept 返回⽤于传输的 socket 的⽂件描述符；
客户端调⽤ write 写⼊数据；服务端调⽤ read 读取数据；
客户端断开连接时，会调⽤ close ，那么服务端 read 读取数据的时候，就会读取到了 EOF ，待
处理完数据后，服务端调⽤ close ，表示连接关闭。
```


## 总结

````
由于每个进程的⽤户空间都是独⽴的，不能相互访问，这时就需要借助内核空间来实现进程间通信，原因
很简单，每个进程都是共享⼀个内核空间。
Linux 内核提供了不少进程间通信的⽅式，其中最简单的⽅式就是管道，管道分为「匿名管道」和「命名管
道」。
匿名管道顾名思义，它没有名字标识，匿名管道是特殊⽂件只存在于内存，没有存在于⽂件系统中，shell
命令中的「 | 」竖线就是匿名管道，通信的数据是⽆格式的流并且⼤⼩受限，通信的⽅式是单向的，数据
只能在⼀个⽅向上流动，如果要双向通信，需要创建两个管道，再来匿名管道是只能⽤于存在⽗⼦关系的
进程间通信，匿名管道的⽣命周期随着进程创建⽽建⽴，随着进程终⽌⽽消失。
命名管道突破了匿名管道只能在亲缘关系进程间的通信限制，因为使⽤命名管道的前提，需要在⽂件系统
创建⼀个类型为 p 的设备⽂件，那么毫⽆关系的进程就可以通过这个设备⽂件进⾏通信。另外，不管是匿
名管道还是命名管道，进程写⼊的数据都是缓存在内核中，另⼀个进程读取数据时候⾃然也是从内核中获
取，同时通信数据都遵循先进先出原则，不⽀持 lseek 之类的⽂件定位操作。
消息队列克服了管道通信的数据是⽆格式的字节流的问题，消息队列实际上是保存在内核的「消息链
表」，消息队列的消息体是可以⽤户⾃定义的数据类型，发送数据时，会被分成⼀个⼀个独⽴的消息体，
当然接收数据时，也要与发送⽅发送的消息体的数据类型保持⼀致，这样才能保证读取的数据是正确的。
消息队列通信的速度不是最及时的，毕竟每次数据的写⼊和读取都需要经过⽤户态与内核态之间的拷⻉过
程。
共享内存可以解决消息队列通信中⽤户态与内核态之间数据拷⻉过程带来的开销，它直接分配⼀个共享空
间，每个进程都可以直接访问，就像访问进程⾃⼰的空间⼀样快捷⽅便，不需要陷⼊内核态或者系统调
⽤，⼤⼤提⾼了通信的速度，享有最快的进程间通信⽅式之名。但是便捷⾼效的共享内存通信，带来新的
问题，多进程竞争同个共享资源会造成数据的错乱。
那么，就需要信号量来保护共享资源，以确保任何时刻只能有⼀个进程访问共享资源，这种⽅式就是互斥
访问。信号量不仅可以实现访问的互斥性，还可以实现进程间的同步，信号量其实是⼀个计数器，表示的
是资源个数，其值可以通过两个原⼦操作来控制，分别是 P 操作和 V 操作。
与信号量名字很相似的叫信号，它俩名字虽然相似，但功能⼀点⼉都不⼀样。信号是进程间通信机制中唯
⼀的异步通信机制，信号可以在应⽤进程和内核之间直接交互，内核也可以利⽤信号来通知⽤户空间的进
程发⽣了哪些系统事件，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令），
⼀旦有信号发⽣，进程有三种⽅式响应信号 1. 执⾏默认操作、2. 捕捉信号、3. 忽略信号。有两个信号是应
⽤进程⽆法捕捉和忽略的，即 SIGKILL 和 SEGSTOP ，这是为了⽅便我们能在任何时候结束或停⽌某
个进程。
前⾯说到的通信机制，都是⼯作于同⼀台主机，如果要与不同主机的进程间通信，那么就需要 Socket 通
信了。Socket 实际上不仅⽤于不同的主机进程间通信，还可以⽤于本地主机进程间通信，可根据创建
Socket 的类型不同，分为三种常⻅的通信⽅式，⼀个是基于 TCP 协议的通信⽅式，⼀个是基于 UDP 协议
的通信⽅式，⼀个是本地进程间通信⽅式。
以上，就是进程间通信的主要机制了。你可能会问了，那线程通信间的⽅式呢？
同个进程下的线程之间都是共享进程的资源，只要是共享变量都可以做到线程间通信，⽐如全局变量，所
以对于线程间关注的不是通信⽅式，⽽是关注多线程竞争共享资源的问题，信号量也同样可以在线程间实
现互斥与同步：
互斥的⽅式，可保证任意时刻只有⼀个线程访问共享资源；
同步的⽅式，可保证线程 A 应在线程 B 之前执⾏；

````
