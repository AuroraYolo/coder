## 最基本的 Socket 模型
```
Socket 的中⽂名叫作插⼝，咋⼀看还挺迷惑的。事实上，双⽅要进⾏⽹络通信前，各⾃得创建⼀个
Socket，这相当于客户端和服务器都开了⼀个“⼝⼦”，双⽅读取和发送数据的时候，都通过这个“⼝⼦”。
这样⼀看，是不是觉得很像弄了⼀根⽹线，⼀头插在客户端，⼀头插在服务端，然后进⾏通信。
创建 Socket 的时候，可以指定⽹络层使⽤的是 IPv4 还是 IPv6，传输层使⽤的是 TCP 还是 UDP。
UDP 的 Socket 编程相对简单些，这⾥我们只介绍基于 TCP 的 Socket 编程。
服务器的程序要先跑起来，然后等待客户端的连接和数据，我们先来看看服务端的 Socket 编程过程是怎样
的。
服务端⾸先调⽤ socket() 函数，创建⽹络协议为 IPv4，以及传输协议为 TCP 的 Socket ，接着调⽤
bind() 函数，给这个 Socket 绑定⼀个 IP 地址和端⼝，绑定这两个的⽬的是什么？
绑定端⼝的⽬的：当内核收到 TCP 报⽂，通过 TCP 头⾥⾯的端⼝号，来找到我们的应⽤程序，然后
把数据传递给我们。
绑定 IP 地址的⽬的：⼀台机器是可以有多个⽹卡的，每个⽹卡都有对应的 IP 地址，当绑定⼀个⽹卡
时，内核在收到该⽹卡上的包，才会发给我们；
绑定完 IP 地址和端⼝后，就可以调⽤ listen() 函数进⾏监听，此时对应 TCP 状态图中的 listen ，如果
我们要判定服务器中⼀个⽹络程序有没有启动，可以通过 netstat 命令查看对应的端⼝号是否有被监听。
服务端进⼊了监听状态后，通过调⽤ accept() 函数，来从内核获取客户端的连接，如果没有客户端连
接，则会阻塞等待客户端连接的到来。
那客户端是怎么发起连接的呢？客户端在创建好 Socket 后，调⽤ connect() 函数发起连接，该函数的参
数要指明服务端的 IP 地址和端⼝号，然后万众期待的 TCP 三次握⼿就开始了。
在 TCP 连接的过程中，服务器的内核实际上为每个 Socket 维护了两个队列：
⼀个是还没完全建⽴连接的队列，称为 TCP 半连接队列，这个队列都是没有完成三次握⼿的连接，
此时服务端处于 syn_rcvd 的状态；
⼀个是⼀件建⽴连接的队列，称为 TCP 全连接队列，这个队列都是完成了三次握⼿的连接，此时服
务端处于 established 状态；
当 TCP 全连接队列不为空后，服务端的 accept() 函数，就会从内核中的 TCP 全连接队列⾥拿出⼀个已
经完成连接的 Socket 返回应⽤程序，后续数据传输都⽤这个 Socket。
注意，监听的 Socket 和真正⽤来传数据的 Socket 是两个：
⼀个叫作监听 Socket；
⼀个叫作已连接 Socket；
连接建⽴后，客户端和服务端就开始相互传输数据了，双⽅都可以通过 read() 和 write() 函数来读写数
据。

⽂件描述符的作⽤是什么？每⼀个进程都有⼀个数据结构 task_struct ，该结构体⾥有⼀个指向「⽂件描
述符数组」的成员指针。该数组⾥列出这个进程打开的所有⽂件的⽂件描述符。数组的下标是⽂件描述
符，是⼀个整数，⽽数组的内容是⼀个指针，指向内核中所有打开的⽂件的列表，也就是说内核可以通过
⽂件描述符找到对应打开的⽂件。
然后每个⽂件都有⼀个 inode，Socket ⽂件的 inode 指向了内核中的 Socket 结构，在这个结构体⾥有两
个队列，分别是发送队列和接收队列，这个两个队列⾥⾯保存的是⼀个个 struct sk_buff ，⽤链表的组织
形式串起来。
sk_buff 可以表示各个层的数据包，在应⽤层数据包叫 data，在 TCP 层我们称为 segment，在 IP 层我们
叫 packet，在数据链路层称为 frame。
你可能会好奇，为什么全部数据包只⽤⼀个结构体来描述呢？协议栈采⽤的是分层结构，上层向下层传递
数据时需要增加包头，下层向上层数据时⼜需要去掉包头，如果每⼀层都⽤⼀个结构体，那在层之间传递
数据的时候，就要发⽣多次拷⻉，这将⼤⼤降低 CPU 效率。
于是，为了在层级之间传递数据时，不发⽣拷⻉，只⽤ sk_buff ⼀个结构体来描述所有的⽹络包，那它是
如何做到的呢？是通过调整 sk_buff 中 data 的指针，⽐如：
当接收报⽂时，从⽹卡驱动开始，通过协议栈层层往上传送数据报，通过增加 skb->data 的值，来逐
步剥离协议⾸部。
当要发送报⽂时，创建 sk_buff 结构体，数据缓存区的头部预留⾜够的空间，⽤来填充各层⾸部，在
经过各下层协议时，通过减少 skb->data 的值来增加协议⾸部。
```
