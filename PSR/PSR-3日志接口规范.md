## 日志接口规范
```
1.LoggerInterface 接口对外定义了八个方法，分别用来记录 RFC 5424 中定义的八个等级的日志：debug、 info、 notice、 warning、 error、 critical、 alert 以及 emergency 。
  
  第九个方法 —— log，其第一个参数为记录的等级。可使用一个预先定义的等级常量作为参数来调用此方法，必须 与直接调用以上八个方法具有相同的效果。如果传入的等级常量参数没有预先定义，则 必须 抛出 Psr\Log\InvalidArgumentException 类型的异常。在不确定的情况下，使用者 不该 使用未支持的等级常量来调用此方法。

2.消息
  以上每个方法都接受一个字符串类型或者是有 __toString() 方法的对象作为记录信息参数，这样，实现者就能把它当成字符串来处理，否则实现者 必须 自己把它转换成字符串。
  记录信息参数 可以 携带占位符，实现者 可以 根据上下文将其它替换成相应的值。
  其中占位符 必须 与上下文数组中的键名保持一致。
  占位符的名称 必须 由一个左花括号 { 以及一个右括号 } 包含。但花括号与名称之间 一定不可有空格符。
  占位符的名称 应该 只由 A-Z、a-z、0-9、下划线 _、以及英文的句号 . 组成，其它字符作为将来占位符规范的保留。
  实现者 可以 通过对占位符采用不同的转义和转换策略，来生成最终的日志。
  而使用者在不知道上下文的前提下，不该 提前转义占位符。

3.上下文
 每个记录函数都接受一个上下文数组参数，用来装载字符串类型无法表示的信息。它 可以 装载任何信息，所以实现者 必须 确保能正确处理其装载的信息，对于其装载的数据， 一定不可 抛出异常，或产生 PHP 出错、警告或提醒信息（error、warning、notice）。
 如需通过上下文参数传入了一个 Exception 对象，必须 以 exception 作为键名。
 记录异常信息是很普遍的，所以如果它能够在记录类库的底层实现，就能够让实现者从异常信息中抽丝剥茧。
 当然，实现者在使用它时，必须 确保键名为 exception 的键值是否真的是一个 Exception，毕竟它 可以 装载任何信息。

4.助手类和接口
 Psr\Log\AbstractLogger 类使得只需继承它和实现其中的 log 方法，就能够很轻易地实现 LoggerInterface 接口，而另外八个方法就能够把记录信息和上下文信息传给它。

 同样地，使用 Psr\Log\LoggerTrait 也只需实现其中的 log 方法。不过，需要特别注意的是，在 traits 可复用代码块还不能实现接口前，还需要 implement LoggerInterface。

 在没有可用的日志记录器时，Psr\Log\NullLogger 接口 可以 为使用者提供一个备用的日志「黑洞」。不过，当上下文的构建非常消耗资源时，带条件检查的日志记录或许是更好的办法。

 Psr\Log\LoggerAwareInterface 接口仅包括一个setLogger(LoggerInterface $logger) 方法，框架可以使用它实现自动连接任意的日志记录实例。

 Psr\Log\LoggerAwareTrait trait 可复用代码块可以在任何的类里面使用，只需通过它提供的 $this->logger，就可以轻松地实现等同的接口。
 Psr\Log\LogLevel 类装载了八个记录等级常量

5.接口和类的描述、相关的异常类以及用于验证你所写代码的测试套件都将作为 psr/log 包的一部分提供

6.Psr\Log\LoggerInterface

7.Psr\Log\LoggerAwareInterface

8.Psr\Log\LogLevel 


  

